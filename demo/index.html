<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Three.js MorphTarget äººè„¸åŠ¨ç”»æ¼”ç¤º</title>
  <style>
    body { 
      margin: 0; 
      background: #666; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    #info { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      color: white; 
      z-index: 1; 
    }
  </style>
</head>
<body>
  <!-- <div id="info">
    three.js - MorphTarget äººè„¸è¡¨æƒ…åŠ¨ç”»<br/>
    ä½¿ç”¨å³ä¾§æ§åˆ¶é¢æ¿è°ƒèŠ‚è¡¨æƒ…
  </div> -->
  <div id="audioControls" style="position:absolute; top:40px; left:10px; z-index:1; color:white; font-size:12px; line-height:18px;">
    <label>ä¸Šä¼ éŸ³é¢‘é©±åŠ¨å£å‹ï¼š</label>
    <input id="audioFileInput" type="file" accept="audio/*" />
    <br/>
    <audio id="audioPlayer" controls style="width:260px; margin-top:4px;"></audio>
  </div>

  <!-- Three.js ESæ¨¡å—å¯¼å…¥æ˜ å°„ -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <!-- lil-guiï¼šç”¨äºåˆ›å»ºæ§åˆ¶é¢æ¿ -->
  <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.21.0/dist/lil-gui.umd.min.js"></script>

  <script type="module">
    // ==================== å¯¼å…¥Three.jsç›¸å…³æ¨¡å— ====================
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';  // è½¨é“æ§åˆ¶å™¨ï¼šç”¨äºç›¸æœºäº¤äº’
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';          // GLTFåŠ è½½å™¨ï¼šåŠ è½½3Dæ¨¡å‹
    import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';          // KTX2åŠ è½½å™¨ï¼šåŠ è½½å‹ç¼©çº¹ç†
    import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js'; // Meshoptè§£ç å™¨ï¼šè§£å‹ç¼©å‡ ä½•ä½“

    // ==================== å…¨å±€å˜é‡å£°æ˜ ====================
    let scene, camera, renderer, clock, mixer, controls;  // Three.jsåŸºç¡€å¯¹è±¡
    let headMesh = null;                    // åŒ…å«BlendShapeçš„å¤´éƒ¨ç½‘æ ¼å¯¹è±¡
    let morphTargetInfluences = null;       // BlendShapeå½±å“å€¼æ•°ç»„ï¼ˆæ§åˆ¶è¡¨æƒ…å¼ºåº¦ï¼‰
    let morphTargetDictionary = null;       // BlendShapeåç§°åˆ°ç´¢å¼•çš„æ˜ å°„å­—å…¸
    let speechAnimation = null;             // è¯´è¯åŠ¨ç”»æ§åˆ¶å™¨
    let expressionAnimation = null;         // è¡¨æƒ…åŠ¨ç”»æ§åˆ¶å™¨
    let blinkInterval = null;               // çœ¨çœ¼å®šæ—¶å™¨
    let audioContext = null;                // éŸ³é¢‘ä¸Šä¸‹æ–‡
    let audioAnalyser = null;               // éŸ³é¢‘åˆ†æå™¨
    let audioTimeData = null;               // æ—¶åŸŸæ•°æ®ç¼“å­˜
    let audioFreqData = null;               // é¢‘åŸŸæ•°æ®ç¼“å­˜
    let audioSourceNode = null;             // åª’ä½“æºèŠ‚ç‚¹
    let audioDriveEnabled = false;          // æ˜¯å¦å¯ç”¨éŸ³é¢‘é©±åŠ¨å£å‹
    let audioSmoothLevel = 0;               // å¹³æ»‘åçš„éŸ³é‡
    let audioPlayerEl = null;               // éŸ³é¢‘æ’­æ”¾å™¨å…ƒç´ 
    
    // ==================== åŠ¨ç”»ç›¸å…³ ====================
    let animations = [];                    // å­˜å‚¨æ¨¡å‹è‡ªå¸¦çš„æ‰€æœ‰åŠ¨ç”»
    let currentAction = null;               // å½“å‰æ’­æ”¾çš„åŠ¨ç”»åŠ¨ä½œ
    let animationClips = {};                // åŠ¨ç”»å‰ªè¾‘æ˜ å°„è¡¨
    
    // ==================== åŠ¨ç”»æ§åˆ¶å¼€å…³ ====================
    let autoAnimationEnabled = false;       // è‡ªåŠ¨åŠ¨ç”»æ€»å¼€å…³ï¼ˆé»˜è®¤å…³é—­ï¼‰
    let manualControlActive = false;        // æ‰‹åŠ¨æ§åˆ¶æ¨¡å¼æ ‡å¿—
    let animationMode = 'none';             // åŠ¨ç”»æ¨¡å¼ï¼š'none'æ— åŠ¨ç”», 'builtin'å†…ç½®åŠ¨ç”», 'speech'è¯´è¯åŠ¨ç”»

    // ==================== åˆå§‹åŒ–å’Œå¯åŠ¨ ====================
    init();     // åˆå§‹åŒ–åœºæ™¯
    animate();  // å¯åŠ¨æ¸²æŸ“å¾ªç¯

    /**
     * åˆå§‹åŒ–å‡½æ•°ï¼šè®¾ç½®åœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨ã€å…‰ç…§å’ŒåŠ è½½æ¨¡å‹
     */
    function init() {
      // åˆ›å»ºæ—¶é’Ÿå¯¹è±¡ï¼Œç”¨äºè®¡ç®—å¸§é—´éš”æ—¶é—´
      clock = new THREE.Clock();

      // ========== åˆ›å»ºåœºæ™¯ ==========
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x666666);  // è®¾ç½®ç°è‰²èƒŒæ™¯

      // ========== åˆ›å»ºç›¸æœº ==========
      // é€è§†ç›¸æœºï¼šè§†é‡è§’åº¦45åº¦ï¼Œå®½é«˜æ¯”ï¼Œè¿‘è£å‰ªé¢0.1ï¼Œè¿œè£å‰ªé¢100
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(-1.8, 0.8, 3);  // åˆå§‹ç›¸æœºä½ç½®

      // ========== åˆ›å»ºæ¸²æŸ“å™¨ ==========
      renderer = new THREE.WebGLRenderer({ antialias: true });  // å¼€å¯æŠ—é”¯é½¿
      renderer.setSize(window.innerWidth, window.innerHeight);  // è®¾ç½®æ¸²æŸ“å°ºå¯¸
      document.body.appendChild(renderer.domElement);           // å°†æ¸²æŸ“ç”»å¸ƒæ·»åŠ åˆ°é¡µé¢

      // ========== åˆ›å»ºè½¨é“æ§åˆ¶å™¨ ==========
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;  // å¼€å¯é˜»å°¼ï¼ˆæƒ¯æ€§ï¼‰ï¼Œä½¿æ§åˆ¶æ›´å¹³æ»‘

      // ========== æ·»åŠ å…‰ç…§ ==========
      // ç¯å¢ƒå…‰ï¼šæä¾›åŸºç¡€ç…§æ˜
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      // å¹³è¡Œå…‰1ï¼šä»å³ä¸Šæ–¹ç…§å°„
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);
      
      // å¹³è¡Œå…‰2ï¼šä»å·¦ä¸‹æ–¹è¡¥å…‰
      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-5, -5, -5);
      scene.add(directionalLight2);
      
      // ========== æ·»åŠ è¾…åŠ©ç½‘æ ¼ï¼ˆç”¨äºè°ƒè¯•ï¼Œå¯é€‰ï¼‰ ==========
      const gridHelper = new THREE.GridHelper(10, 10);  // 10x10ç½‘æ ¼
      scene.add(gridHelper);
      
      // åæ ‡è½´è¾…åŠ©ï¼šçº¢è‰²Xè½´ï¼Œç»¿è‰²Yè½´ï¼Œè“è‰²Zè½´
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      // ========== é…ç½®GLTFåŠ è½½å™¨ ==========
      const loader = new GLTFLoader();
      
      // é…ç½®KTX2çº¹ç†åŠ è½½å™¨ï¼ˆç”¨äºå‹ç¼©çº¹ç†ï¼‰
      const ktx2Loader = new KTX2Loader();
      ktx2Loader.setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis/');
      ktx2Loader.detectSupport(renderer);
      loader.setKTX2Loader(ktx2Loader);
      
      // é…ç½®Meshoptè§£ç å™¨ï¼ˆç”¨äºå‹ç¼©å‡ ä½•ä½“ï¼‰
      loader.setMeshoptDecoder(MeshoptDecoder);
      
      // ========== åŠ è½½GLBæ¨¡å‹ ==========
      loader.load(
        './models/facecap.glb',  // æ¨¡å‹è·¯å¾„
        
        // åŠ è½½æˆåŠŸå›è°ƒ
        function(gltf) {
          console.log('âœ“ æ¨¡å‹åŠ è½½æˆåŠŸ');
          
          // ===== åˆ†æGLTF JSONç»“æ„ï¼ŒæŸ¥æ‰¾BlendShapeä¿¡æ¯ =====
          console.log('\n========== GLB BlendShape åˆ†æ ==========');
          analyzeGLTFBlendShapes(gltf);
          
          // ===== å°†æ¨¡å‹æ·»åŠ åˆ°åœºæ™¯ =====
          scene.add(gltf.scene);

          // ===== è®¡ç®—æ¨¡å‹è¾¹ç•Œæ¡†å¹¶å±…ä¸­ =====
          const box = new THREE.Box3().setFromObject(gltf.scene);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          // å°†æ¨¡å‹ç§»åŠ¨åˆ°åŸç‚¹
          gltf.scene.position.set(-center.x, -center.y, -center.z);

          // ===== è‡ªåŠ¨è°ƒæ•´ç›¸æœºä½ç½®ä»¥é€‚åº”æ¨¡å‹ =====
          const maxDim = Math.max(size.x, size.y, size.z);
          const fov = camera.fov * (Math.PI / 180);
          let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
          cameraZ *= 2;  // æ·»åŠ ä¸€äº›è¾¹è·
          
          camera.position.set(0, 0, cameraZ);
          camera.lookAt(0, 0, 0);
          controls.target.set(0, 0, 0);
          controls.update();
          
          // ===== éå†æ¨¡å‹æŸ¥æ‰¾åŒ…å«BlendShapeçš„ç½‘æ ¼ =====
          console.log('\n========== Three.js ç½‘æ ¼åˆ†æ ==========');
          gltf.scene.traverse(function(child) {
            if(child.isMesh) {
              analyzeAndSetupMorphTargets(child);
            }
          });
          console.log('==========================================\n');
          
          // ===== è®¾ç½®åŠ¨ç”»æ··åˆå™¨ï¼ˆå¦‚æœæ¨¡å‹åŒ…å«åŠ¨ç”»ï¼‰ =====
          mixer = new THREE.AnimationMixer(gltf.scene);
          animations = gltf.animations;  // ä¿å­˜æ‰€æœ‰åŠ¨ç”»
          
          if(animations.length > 0) {
            console.log(`âœ“ å‘ç° ${animations.length} ä¸ªæ¨¡å‹è‡ªå¸¦åŠ¨ç”»:`);
            
            // åˆ—å‡ºæ‰€æœ‰åŠ¨ç”»å¹¶åˆ›å»ºæ˜ å°„
            animations.forEach((clip, index) => {
              const clipName = clip.name || `åŠ¨ç”»_${index}`;
              animationClips[clipName] = clip;
              console.log(`  [${index}] ${clipName} (æ—¶é•¿: ${clip.duration.toFixed(2)}ç§’)`);
            });
            
            // é»˜è®¤ä¸è‡ªåŠ¨æ’­æ”¾ï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©
          } else {
            console.log('æ¨¡å‹ä¸åŒ…å«é¢„è®¾åŠ¨ç”»');
          }

          // ===== å¦‚æœæ‰¾åˆ°äº†åŒ…å«BlendShapeçš„ç½‘æ ¼ï¼Œåˆå§‹åŒ–æ§åˆ¶ç³»ç»Ÿ =====
          if(headMesh) {
            console.log('âœ“ BlendShapeåˆå§‹åŒ–å®Œæˆ');
            
            // åˆå§‹åŒ–è¯´è¯åŠ¨ç”»ç³»ç»Ÿ
            initSpeechAnimation();
            
            // åˆå§‹åŒ–è¡¨æƒ…åŠ¨ç”»ç³»ç»Ÿ
            initExpressionAnimation();
            
            // åˆ›å»ºGUIæ§åˆ¶é¢æ¿
            createGUI();
            
            // æ³¨æ„ï¼šä¸è‡ªåŠ¨å¯åŠ¨åŠ¨ç”»ï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨æ§åˆ¶
            // å¦‚æœéœ€è¦è‡ªåŠ¨å¼€å§‹ï¼Œå–æ¶ˆä¸‹é¢çš„æ³¨é‡Šï¼š
            /*
            setTimeout(() => {
              if(autoAnimationEnabled) {
                startBlinking();
                if(speechAnimation) {
                  speechAnimation.startTalking();
                }
              }
            }, 1000);
            */
          } else {
            console.error('âœ— æœªæ‰¾åˆ°åŒ…å«MorphTargetçš„ç½‘æ ¼ï¼');
            alert('æ¨¡å‹ä¸­æœªæ‰¾åˆ°BlendShape/MorphTargetæ•°æ®ï¼Œæ— æ³•æ’­æ”¾è¡¨æƒ…åŠ¨ç”»ã€‚');
          }
        },
        
        // åŠ è½½è¿›åº¦å›è°ƒ
        function(progress) {
          const percent = (progress.loaded / progress.total * 100).toFixed(2);
          console.log(`åŠ è½½è¿›åº¦: ${percent}%`);
        },
        
        // åŠ è½½å¤±è´¥å›è°ƒ
        function(error) { 
          console.error('âœ— æ¨¡å‹åŠ è½½å¤±è´¥:', error); 
          alert('æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„å’Œæ ¼å¼ã€‚');
        }
      );

      // ========== ç›‘å¬çª—å£å¤§å°å˜åŒ– ==========
      window.addEventListener('resize', onWindowResize);

      // ========== åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¼ ä¸æ’­æ”¾ ==========
      setupAudioUI();
    }

    /**
     * åˆ†æGLTFæ–‡ä»¶ä¸­çš„BlendShapeä¿¡æ¯
     */
    function analyzeGLTFBlendShapes(gltf) {
      if(!gltf.parser || !gltf.parser.json) return;
      
      const json = gltf.parser.json;
      
      if(json.meshes) {
        console.log(`å‘ç° ${json.meshes.length} ä¸ªç½‘æ ¼`);
        
        json.meshes.forEach((mesh, meshIndex) => {
          if(mesh.primitives) {
            mesh.primitives.forEach((primitive, primIndex) => {
              if(primitive.targets && primitive.targets.length > 0) {
                console.log(`  ç½‘æ ¼ ${meshIndex} - å›¾å…ƒ ${primIndex}: ${primitive.targets.length} ä¸ªBlendShape`);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰BlendShapeåç§°
                if(primitive.extras && primitive.extras.targetNames) {
                  console.log('  BlendShapeåç§°:', primitive.extras.targetNames);
                } else {
                  console.log('  (æœªå‘½åBlendShapeï¼Œå°†ä½¿ç”¨ç´¢å¼•)');
                }
              }
            });
          }
        });
      }
    }

    /**
     * åˆ†æå¹¶è®¾ç½®ç½‘æ ¼çš„MorphTarget
     */
    function analyzeAndSetupMorphTargets(child) {
      console.log(`\nç½‘æ ¼: ${child.name || 'æœªå‘½å'}`);
      
      // æ£€æŸ¥å‡ ä½•ä½“æ˜¯å¦æœ‰morphAttributes
      if(!child.geometry || !child.geometry.morphAttributes) {
        console.log('  âœ— æ— morphAttributes');
        return;
      }
      
      const morphAttributes = child.geometry.morphAttributes;
      
      // æ£€æŸ¥positionç±»å‹çš„morph attributesï¼ˆæœ€å¸¸è§ï¼‰
      if(!morphAttributes.position || morphAttributes.position.length === 0) {
        console.log('  âœ— æ— position morph attributes');
        return;
      }
      
      const morphCount = morphAttributes.position.length;
      console.log(`  âœ“ å‘ç° ${morphCount} ä¸ªBlendShape`);
      
      // ===== åˆå§‹åŒ–morphTargetInfluencesæ•°ç»„ =====
      if(!child.morphTargetInfluences || child.morphTargetInfluences.length === 0) {
        child.morphTargetInfluences = new Array(morphCount).fill(0);
        console.log('  âœ“ åˆå§‹åŒ–morphTargetInfluencesæ•°ç»„');
      }
      
      // ===== åˆ›å»ºæˆ–è·å–morphTargetDictionary =====
      if(!child.morphTargetDictionary) {
        child.morphTargetDictionary = {};
        
        // å°è¯•ä»userDataè·å–åç§°
        if(child.geometry.userData && child.geometry.userData.morphTargetNames) {
          child.geometry.userData.morphTargetNames.forEach((name, index) => {
            child.morphTargetDictionary[name] = index;
          });
        } else {
          // åˆ›å»ºé»˜è®¤åç§°
          for(let i = 0; i < morphCount; i++) {
            child.morphTargetDictionary[`blendshape_${i}`] = i;
          }
        }
      }
      
      // ===== ä½¿ç”¨ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„åŒ…å«BlendShapeçš„ç½‘æ ¼ =====
      if(!headMesh) {
        headMesh = child;
        morphTargetInfluences = child.morphTargetInfluences;
        morphTargetDictionary = child.morphTargetDictionary;
        
        console.log('  âœ“ å·²é€‰æ‹©ä¸ºå¤´éƒ¨ç½‘æ ¼');
        console.log('  BlendShapeåˆ—è¡¨:');
        
        // æŒ‰ç´¢å¼•æ’åºå¹¶æ‰“å°æ‰€æœ‰BlendShapeåç§°
        const sortedEntries = Object.entries(morphTargetDictionary).sort((a, b) => a[1] - b[1]);
        sortedEntries.forEach(([name, index]) => {
          console.log(`    [${index}] ${name}`);
        });
      }
    }

    /**
     * åˆå§‹åŒ–è¯´è¯åŠ¨ç”»ç³»ç»Ÿ
     * æ ¹æ®BlendShapeåç§°åŒ¹é…å¸¸è§çš„éŸ³ç´ å½¢çŠ¶
     */
    function initSpeechAnimation() {
      if(!headMesh || !morphTargetInfluences) return;

      // å¸¸è§éŸ³ç´ å¯¹åº”çš„BlendShapeåç§°ï¼ˆå¯æ ¹æ®å®é™…æ¨¡å‹è°ƒæ•´ï¼‰
      const phonemes = {
        'A': ['A', 'a', 'ah', 'open', 'jawOpen', 'mouthOpen', 'aa'],
        'E': ['E', 'e', 'eh', 'smile', 'mouthSmile', 'ee'],
        'I': ['I', 'i', 'ee', 'mouthNarrow', 'ii'],
        'O': ['O', 'o', 'oh', 'mouthRound', 'oo'],
        'U': ['U', 'u', 'oo', 'mouthPucker', 'uu'],
        'M': ['M', 'm', 'mouthClose', 'lipsTogether', 'pp'],
      };

      // æŸ¥æ‰¾éŸ³ç´ å¯¹åº”çš„BlendShapeç´¢å¼•
      const phonemeIndices = {};
      for(const [phoneme, names] of Object.entries(phonemes)) {
        for(const name of names) {
          // ç²¾ç¡®åŒ¹é…
          if(morphTargetDictionary[name] !== undefined) {
            phonemeIndices[phoneme] = morphTargetDictionary[name];
            break;
          }
          // æ¨¡ç³ŠåŒ¹é…ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
          for(const [key, index] of Object.entries(morphTargetDictionary)) {
            if(key.toLowerCase().includes(name.toLowerCase())) {
              phonemeIndices[phoneme] = index;
              break;
            }
          }
          if(phonemeIndices[phoneme] !== undefined) break;
        }
      }

      console.log('éŸ³ç´ æ˜ å°„:', phonemeIndices);
      
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„éŸ³ç´ ï¼Œä½¿ç”¨å‰å‡ ä¸ªBlendShapeä½œä¸ºå¤‡ç”¨
      if(Object.keys(phonemeIndices).length === 0 && morphTargetInfluences.length > 0) {
        console.warn('æœªæ‰¾åˆ°åŒ¹é…çš„éŸ³ç´ åç§°ï¼Œä½¿ç”¨å‰å‡ ä¸ªBlendShapeä½œä¸ºå¤‡ç”¨');
        const fallbackPhonemes = ['A', 'E', 'I', 'O', 'U', 'M'];
        fallbackPhonemes.forEach((phoneme, i) => {
          if(i < morphTargetInfluences.length) {
            phonemeIndices[phoneme] = i;
          }
        });
      }

      // ===== è¯´è¯åŠ¨ç”»æ§åˆ¶å™¨å¯¹è±¡ =====
      speechAnimation = {
        phonemes: phonemeIndices,           // éŸ³ç´ åˆ°ç´¢å¼•çš„æ˜ å°„
        isSpeaking: false,                  // æ˜¯å¦æ­£åœ¨è¯´è¯
        currentPhoneme: null,               // å½“å‰éŸ³ç´ 
        speed: 0.15,                        // è¯´è¯é€Ÿåº¦ï¼ˆç§’/éŸ³ç´ ï¼‰
        intensity: 0.8,                     // è¯´è¯å¼ºåº¦
        allMorphIndices: Array.from({length: morphTargetInfluences.length}, (_, i) => i),
        
        /**
         * æ’­æ”¾éŸ³ç´ åºåˆ—
         */
        speak: function(phonemeSequence) {
          if(!this.isSpeaking && autoAnimationEnabled) {
            this.isSpeaking = true;
            this.playSequence(phonemeSequence, 0);
          }
        },
        
        /**
         * é€’å½’æ’­æ”¾éŸ³ç´ åºåˆ—
         */
        playSequence: function(sequence, index) {
          if(index >= sequence.length || !autoAnimationEnabled) {
            this.isSpeaking = false;
            this.resetMouth();
            return;
          }
          
          const phoneme = sequence[index];
          this.setPhoneme(phoneme);
          
          setTimeout(() => {
            this.playSequence(sequence, index + 1);
          }, this.speed * 1000);
        },
        
        /**
         * è®¾ç½®å½“å‰éŸ³ç´ 
         */
        setPhoneme: function(phoneme) {
          if(!autoAnimationEnabled || manualControlActive) return;
          if(this.phonemes[phoneme] === undefined) return;
          
          this.resetMouth();
          morphTargetInfluences[this.phonemes[phoneme]] = this.intensity;
          this.currentPhoneme = phoneme;
        },
        
        /**
         * é‡ç½®å˜´éƒ¨å½¢çŠ¶
         */
        resetMouth: function() {
          if(manualControlActive) return;
          
          for(const index of Object.values(this.phonemes)) {
            if(index !== undefined) {
              morphTargetInfluences[index] = 0;
            }
          }
          this.currentPhoneme = null;
        },
        
        /**
         * å¼€å§‹è¿ç»­è¯´è¯åŠ¨ç”»
         */
        startTalking: function() {
          if(this.isSpeaking || !autoAnimationEnabled) return;
          this.isSpeaking = true;
          manualControlActive = false;
          this.talkLoop();
        },
        
        /**
         * åœæ­¢è¯´è¯åŠ¨ç”»
         */
        stopTalking: function() {
          this.isSpeaking = false;
          this.resetMouth();
        },
        
        /**
         * è¯´è¯åŠ¨ç”»å¾ªç¯
         */
        talkLoop: function() {
          if(!this.isSpeaking || !autoAnimationEnabled || manualControlActive) {
            this.isSpeaking = false;
            return;
          }
          
          // éšæœºé€‰æ‹©éŸ³ç´ 
          const randomPhonemes = Object.keys(this.phonemes);
          if(randomPhonemes.length === 0) return;
          
          const randomPhoneme = randomPhonemes[Math.floor(Math.random() * randomPhonemes.length)];
          this.setPhoneme(randomPhoneme);
          
          // éšæœºåœé¡¿ï¼Œæ›´è‡ªç„¶
          const pause = this.speed * 1000 + (Math.random() * 100);
          
          setTimeout(() => {
            if(this.isSpeaking && autoAnimationEnabled) {
              this.resetMouth();
              setTimeout(() => this.talkLoop(), 50);
            }
          }, pause);
        }
      };
    }

    /**
     * åˆå§‹åŒ–è¡¨æƒ…åŠ¨ç”»ç³»ç»Ÿ
     */
    function initExpressionAnimation() {
      if(!headMesh || !morphTargetInfluences) return;

      // å¸¸è§è¡¨æƒ…å¯¹åº”çš„BlendShapeåç§°
      const expressions = {
        'smile': ['smile', 'happy', 'joy', 'grin', 'mouthSmile'],
        'frown': ['frown', 'sad', 'sadness', 'mouthFrown'],
        'surprise': ['surprise', 'surprised', 'shock', 'eyebrowUp', 'browUp'],
        'anger': ['anger', 'angry', 'mad', 'furious', 'browDown'],
        'blink': ['blink', 'wink', 'eyeClose', 'eyesClosed'],
      };

      // æŸ¥æ‰¾è¡¨æƒ…å¯¹åº”çš„BlendShapeç´¢å¼•
      const expressionIndices = {};
      for(const [expression, names] of Object.entries(expressions)) {
        for(const name of names) {
          if(morphTargetDictionary[name] !== undefined) {
            expressionIndices[expression] = morphTargetDictionary[name];
            break;
          }
          for(const [key, index] of Object.entries(morphTargetDictionary)) {
            if(key.toLowerCase().includes(name.toLowerCase())) {
              expressionIndices[expression] = index;
              break;
            }
          }
          if(expressionIndices[expression] !== undefined) break;
        }
      }

      console.log('è¡¨æƒ…æ˜ å°„:', expressionIndices);

      // ===== è¡¨æƒ…åŠ¨ç”»æ§åˆ¶å™¨å¯¹è±¡ =====
      expressionAnimation = {
        expressions: expressionIndices,
        currentExpression: null,
        intensity: 0.8,
        
        /**
         * è®¾ç½®è¡¨æƒ…
         */
        setExpression: function(expression, value = null) {
          if(this.expressions[expression] !== undefined) {
            const targetValue = value !== null ? value : this.intensity;
            morphTargetInfluences[this.expressions[expression]] = targetValue;
            this.currentExpression = expression;
          }
        },
        
        /**
         * æ¸…é™¤æŒ‡å®šè¡¨æƒ…
         */
        clearExpression: function(expression) {
          if(this.expressions[expression] !== undefined) {
            morphTargetInfluences[this.expressions[expression]] = 0;
          }
        },
        
        /**
         * æ¸…é™¤æ‰€æœ‰è¡¨æƒ…
         */
        clearAll: function() {
          for(const index of Object.values(this.expressions)) {
            if(index !== undefined) {
              morphTargetInfluences[index] = 0;
            }
          }
          this.currentExpression = null;
        }
      };
    }

    /**
     * å¼€å§‹éšæœºçœ¨çœ¼åŠ¨ç”»
     */
    function startBlinking() {
      if(!expressionAnimation || !autoAnimationEnabled) return;
      
      // åœæ­¢ä¹‹å‰çš„çœ¨çœ¼å®šæ—¶å™¨
      if(blinkInterval) {
        clearTimeout(blinkInterval);
      }
      
      const blink = () => {
        if(!autoAnimationEnabled || manualControlActive) return;
        
        const blinkDelay = 2000 + Math.random() * 3000;  // 2-5ç§’éšæœºé—´éš”
        
        blinkInterval = setTimeout(() => {
          if(expressionAnimation.expressions.blink !== undefined && autoAnimationEnabled && !manualControlActive) {
            // å¿«é€Ÿçœ¨çœ¼
            morphTargetInfluences[expressionAnimation.expressions.blink] = 1;
            setTimeout(() => {
              if(!manualControlActive) {
                morphTargetInfluences[expressionAnimation.expressions.blink] = 0;
              }
            }, 100);
          }
          blink();  // é€’å½’è°ƒç”¨ï¼Œç»§ç»­ä¸‹ä¸€æ¬¡çœ¨çœ¼
        }, blinkDelay);
      };
      
      blink();
    }

    /**
     * åœæ­¢éšæœºçœ¨çœ¼åŠ¨ç”»
     */
    function stopBlinking() {
      if(blinkInterval) {
        clearTimeout(blinkInterval);
        blinkInterval = null;
      }
    }

    /**
     * æ’­æ”¾æ¨¡å‹å†…ç½®åŠ¨ç”»
     * @param {string} clipName - åŠ¨ç”»åç§°
     */
    function playBuiltinAnimation(clipName) {
      if(!mixer || !animationClips[clipName]) {
        console.error('åŠ¨ç”»ä¸å­˜åœ¨:', clipName);
        return;
      }
      
      // åœæ­¢å½“å‰åŠ¨ç”»
      if(currentAction) {
        currentAction.fadeOut(0.5);
      }
      
      // åœæ­¢è¯´è¯åŠ¨ç”»
      if(speechAnimation) {
        speechAnimation.stopTalking();
      }
      stopBlinking();
      
      // æ’­æ”¾é€‰ä¸­çš„åŠ¨ç”»
      currentAction = mixer.clipAction(animationClips[clipName]);
      currentAction.reset();
      currentAction.fadeIn(0.5);
      currentAction.play();
      
      animationMode = 'builtin';
      manualControlActive = false;
      
      console.log(`âœ“ æ’­æ”¾å†…ç½®åŠ¨ç”»: ${clipName}`);
    }
    
    /**
     * åœæ­¢æ¨¡å‹å†…ç½®åŠ¨ç”»
     */
    function stopBuiltinAnimation() {
      if(currentAction) {
        currentAction.fadeOut(0.5);
        currentAction = null;
      }
      
      animationMode = 'none';
      console.log('âœ“ å·²åœæ­¢å†…ç½®åŠ¨ç”»');
    }
    
    /**
     * æ’­æ”¾æ‰€æœ‰å†…ç½®åŠ¨ç”»ï¼ˆå¾ªç¯æ’­æ”¾ï¼‰
     */
    function playAllBuiltinAnimations() {
      if(!mixer || animations.length === 0) return;
      
      // åœæ­¢è¯´è¯åŠ¨ç”»
      if(speechAnimation) {
        speechAnimation.stopTalking();
      }
      stopBlinking();
      
      // åœæ­¢å½“å‰åŠ¨ç”»
      if(currentAction) {
        currentAction.stop();
      }
      
      // æ’­æ”¾æ‰€æœ‰åŠ¨ç”»å¹¶å¾ªç¯
      animations.forEach((clip) => {
        const action = mixer.clipAction(clip);
        action.setLoop(THREE.LoopRepeat);
        action.play();
      });
      
      animationMode = 'builtin';
      manualControlActive = false;
      
      console.log('âœ“ æ’­æ”¾æ‰€æœ‰å†…ç½®åŠ¨ç”»ï¼ˆå¾ªç¯ï¼‰');
    }

    /**
     * åˆ›å»ºGUIæ§åˆ¶é¢æ¿
     */
    function createGUI() {
      const gui = new lil.GUI();
      gui.title('è¡¨æƒ…æ§åˆ¶é¢æ¿');
      
      // ========== åŠ¨ç”»æ§åˆ¶åŒº ==========
      const animationFolder = gui.addFolder('åŠ¨ç”»æ§åˆ¶');
      animationFolder.add({ 
        enabled: autoAnimationEnabled 
      }, 'enabled').name('âœ… å¯ç”¨è‡ªåŠ¨åŠ¨ç”»').onChange((value) => {
        autoAnimationEnabled = value;
        if(!value) {
          // å…³é—­è‡ªåŠ¨åŠ¨ç”»æ—¶ï¼Œåœæ­¢æ‰€æœ‰åŠ¨ç”»
          animationMode = 'none';
          if(speechAnimation) speechAnimation.stopTalking();
          stopBlinking();
          stopBuiltinAnimation();
        } else {
          // å¼€å¯è‡ªåŠ¨åŠ¨ç”»æ—¶ï¼Œæ ¹æ®å½“å‰æ¨¡å¼å†³å®šå¯åŠ¨å“ªç§åŠ¨ç”»
          manualControlActive = false;
          // é»˜è®¤ä¸è‡ªåŠ¨å¯åŠ¨ï¼Œè®©ç”¨æˆ·é€‰æ‹©
          console.log('âœ“ è‡ªåŠ¨åŠ¨ç”»å·²å¯ç”¨ï¼Œè¯·é€‰æ‹©è¦æ’­æ”¾çš„åŠ¨ç”»ç±»å‹');
        }
      });
      
      animationFolder.add({ 
        pauseAll: () => {
          autoAnimationEnabled = false;
          animationMode = 'none';
          
          // åœæ­¢è¯´è¯åŠ¨ç”»
          if(speechAnimation) speechAnimation.stopTalking();
          stopBlinking();
          
          // åœæ­¢å†…ç½®åŠ¨ç”»
          stopBuiltinAnimation();
          
          manualControlActive = true;
          console.log('âœ“ å·²æš‚åœæ‰€æœ‰åŠ¨ç”»ï¼Œå¯ä»¥æ‰‹åŠ¨è°ƒèŠ‚è¡¨æƒ…');
        }
      }, 'pauseAll').name('â¸ï¸ æš‚åœæ‰€æœ‰åŠ¨ç”»');
      
      animationFolder.add({ 
        resetAll: () => {
          // é‡ç½®æ‰€æœ‰BlendShape
          for(let i = 0; i < morphTargetInfluences.length; i++) {
            morphTargetInfluences[i] = 0;
          }
          console.log('âœ“ å·²é‡ç½®æ‰€æœ‰è¡¨æƒ…');
        }
      }, 'resetAll').name('é‡ç½®æ‰€æœ‰è¡¨æƒ…');
      
      animationFolder.open();
      
      // ========== æ¨¡å‹å†…ç½®åŠ¨ç”»æ§åˆ¶åŒº ==========
      if(animations.length > 0) {
        const builtinFolder = gui.addFolder('æ¨¡å‹å†…ç½®åŠ¨ç”» ğŸ¬');
        
        // æ·»åŠ åŠ¨ç”»é€‰æ‹©ä¸‹æ‹‰æ¡†
        const animationNames = Object.keys(animationClips);
        const animationControls = {
          selectedAnimation: animationNames[0] || '',
          
          play: () => {
            if(animationControls.selectedAnimation) {
              autoAnimationEnabled = true;
              playBuiltinAnimation(animationControls.selectedAnimation);
            }
          },
          
          stop: () => {
            stopBuiltinAnimation();
            manualControlActive = true;
          },
          
          playAll: () => {
            autoAnimationEnabled = true;
            playAllBuiltinAnimations();
          }
        };
        
        // åŠ¨ç”»é€‰æ‹©å™¨
        if(animationNames.length > 0) {
          builtinFolder.add(animationControls, 'selectedAnimation', animationNames).name('é€‰æ‹©åŠ¨ç”»');
          builtinFolder.add(animationControls, 'play').name('â–¶ï¸ æ’­æ”¾é€‰ä¸­åŠ¨ç”»');
          builtinFolder.add(animationControls, 'stop').name('â¸ï¸ åœæ­¢åŠ¨ç”»');
          
          if(animations.length > 1) {
            builtinFolder.add(animationControls, 'playAll').name('ğŸ” å¾ªç¯æ’­æ”¾æ‰€æœ‰åŠ¨ç”»');
          }
        }
        
        builtinFolder.open();
      }
      
      // ========== è¯´è¯åŠ¨ç”»æ§åˆ¶åŒº ==========
      if(speechAnimation && Object.keys(speechAnimation.phonemes).length > 0) {
        const speechFolder = gui.addFolder('è¯´è¯åŠ¨ç”»');
        speechFolder.add(speechAnimation, 'speed', 0.05, 0.5).name('è¯´è¯é€Ÿåº¦');
        speechFolder.add(speechAnimation, 'intensity', 0, 1).name('è¯´è¯å¼ºåº¦');
        
        speechFolder.add({ 
          start: () => {
            // åœæ­¢å†…ç½®åŠ¨ç”»
            stopBuiltinAnimation();
            
            autoAnimationEnabled = true;
            manualControlActive = false;
            animationMode = 'speech';
            speechAnimation.startTalking();
            startBlinking();
          }
        }, 'start').name('â–¶ï¸ å¼€å§‹è¯´è¯');
        
        speechFolder.add({ 
          stop: () => {
            speechAnimation.stopTalking();
            stopBlinking();
            manualControlActive = true;
            animationMode = 'none';
          }
        }, 'stop').name('â¸ï¸ åœæ­¢è¯´è¯');
        
        // æµ‹è¯•æŒ‰é’®
        speechFolder.add({ 
          test: () => {
            autoAnimationEnabled = true;
            manualControlActive = false;
            speechAnimation.speak(['A', 'E', 'I', 'O', 'U']);
          }
        }, 'test').name('æµ‹è¯•: A-E-I-O-U');
      }

      // ========== éŸ³é¢‘é©±åŠ¨å£å‹ ==========
      const audioFolder = gui.addFolder('éŸ³é¢‘é©±åŠ¨ (ä¸Šä¼ éŸ³é¢‘â†’å£å‹)');
      audioFolder.add({ 
        start: () => {
          startAudioDrivenSpeech();
        }
      }, 'start').name('â–¶ï¸ æ’­æ”¾å¹¶é©±åŠ¨å£å‹');
      audioFolder.add({ 
        stop: () => {
          stopAudioDrivenSpeech();
          manualControlActive = true;
          animationMode = 'none';
        }
      }, 'stop').name('â¸ï¸ åœæ­¢éŸ³é¢‘é©±åŠ¨');
      audioFolder.open();
      
      // ========== è¡¨æƒ…å¿«æ·æ§åˆ¶åŒº ==========
      if(expressionAnimation && Object.keys(expressionAnimation.expressions).length > 0) {
        const expressionFolder = gui.addFolder('å¿«æ·è¡¨æƒ…');
        expressionFolder.add(expressionAnimation, 'intensity', 0, 1).name('è¡¨æƒ…å¼ºåº¦');
        
        for(const expr of Object.keys(expressionAnimation.expressions)) {
          expressionFolder.add({ 
            trigger: () => {
              manualControlActive = true;
              autoAnimationEnabled = false;
              animationMode = 'none';
              
              // åœæ­¢æ‰€æœ‰åŠ¨ç”»
              if(speechAnimation) speechAnimation.stopTalking();
              stopBlinking();
              stopBuiltinAnimation();
              
              // åº”ç”¨è¡¨æƒ…
              expressionAnimation.clearAll();
              expressionAnimation.setExpression(expr);
            }
          }, 'trigger').name(getExpressionNameCN(expr));
        }
        
        expressionFolder.add({ 
          clear: () => {
            expressionAnimation.clearAll();
          }
        }, 'clear').name('æ¸…é™¤è¡¨æƒ…');
      }
      
      // ========== æ‰‹åŠ¨BlendShapeæ§åˆ¶åŒº ==========
      const manualFolder = gui.addFolder('æ‰‹åŠ¨è°ƒèŠ‚BlendShape');
      if(morphTargetDictionary) {
        // åˆ›å»ºå®æ—¶ç»‘å®šçš„æ§åˆ¶å¯¹è±¡
        const liveControls = {};
        
        // æŒ‰ç´¢å¼•æ’åº
        const sortedEntries = Object.entries(morphTargetDictionary).sort((a, b) => a[1] - b[1]);
        
        sortedEntries.forEach(([name, index]) => {
          // ä½¿ç”¨getter/setterå®ç°å®æ—¶åŒå‘ç»‘å®š
          Object.defineProperty(liveControls, name, {
            get: () => morphTargetInfluences[index],
            set: (value) => {
              // å½“æ‰‹åŠ¨è°ƒèŠ‚æ—¶ï¼Œè‡ªåŠ¨æš‚åœè‡ªåŠ¨åŠ¨ç”»
              if(!manualControlActive) {
                manualControlActive = true;
                autoAnimationEnabled = false;
                if(speechAnimation) speechAnimation.stopTalking();
                stopBlinking();
                console.log('âœ“ æ£€æµ‹åˆ°æ‰‹åŠ¨è°ƒèŠ‚ï¼Œå·²è‡ªåŠ¨æš‚åœæ‰€æœ‰åŠ¨ç”»');
              }
              morphTargetInfluences[index] = value;
            }
          });
          
          // æ·»åŠ æ»‘å—æ§åˆ¶
          manualFolder.add(liveControls, name, 0, 1, 0.01).name(`[${index}] ${name}`);
        });
      }
      
      // é»˜è®¤æ‰“å¼€æ‰‹åŠ¨æ§åˆ¶é¢æ¿
      manualFolder.open();
      gui.open();
    }

    /**
     * è·å–è¡¨æƒ…çš„ä¸­æ–‡åç§°
     */
    function getExpressionNameCN(expr) {
      const nameMap = {
        'smile': 'å¾®ç¬‘ ğŸ˜Š',
        'frown': 'çš±çœ‰ ğŸ˜',
        'surprise': 'æƒŠè®¶ ğŸ˜®',
        'anger': 'æ„¤æ€’ ğŸ˜ ',
        'blink': 'çœ¨çœ¼ ğŸ˜‰'
      };
      return nameMap[expr] || expr;
    }

    /**
     * çª—å£å¤§å°æ”¹å˜æ—¶çš„å›è°ƒå‡½æ•°
     */
    function onWindowResize() {
      // æ›´æ–°ç›¸æœºå®½é«˜æ¯”
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      
      // æ›´æ–°æ¸²æŸ“å™¨å°ºå¯¸
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /**
     * åŠ¨ç”»å¾ªç¯å‡½æ•°ï¼šæ¯å¸§è°ƒç”¨
     */
    function animate() {
      requestAnimationFrame(animate);  // è¯·æ±‚ä¸‹ä¸€å¸§

      // æ›´æ–°æ—¶é—´å¢é‡
      const delta = clock.getDelta();
      
      // æ›´æ–°åŠ¨ç”»æ··åˆå™¨ï¼ˆå¦‚æœæœ‰GLTFåŠ¨ç”»ï¼‰
      if(mixer) mixer.update(delta);

      // å¦‚æœå¼€å¯éŸ³é¢‘é©±åŠ¨ï¼Œæ ¹æ®éŸ³é¢‘å®æ—¶é©±åŠ¨å£å‹
      if(audioDriveEnabled && audioAnalyser && !manualControlActive) {
        driveMouthByAudio();
      }

      // æ¸²æŸ“åœºæ™¯
      renderer.render(scene, camera);
      
      // æ›´æ–°è½¨é“æ§åˆ¶å™¨
      controls.update();
    }

    /**
     * åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¼ ä¸æ’­æ”¾ UI
     */
    function setupAudioUI() {
      audioPlayerEl = document.getElementById('audioPlayer');
      const fileInput = document.getElementById('audioFileInput');

      if(fileInput) {
        fileInput.addEventListener('change', (e) => {
          const file = e.target.files && e.target.files[0];
          if(!file) return;
          const url = URL.createObjectURL(file);
          audioPlayerEl.src = url;
          audioPlayerEl.load();
          console.log('âœ“ éŸ³é¢‘å·²é€‰æ‹©ï¼Œå‡†å¤‡é©±åŠ¨å£å‹');
        });
      }

      if(audioPlayerEl) {
        audioPlayerEl.addEventListener('ended', () => {
          stopAudioDrivenSpeech();
        });
      }
    }

    /**
     * å¯åŠ¨éŸ³é¢‘é©±åŠ¨å£å‹
     */
    function startAudioDrivenSpeech() {
      if(!audioPlayerEl || !audioPlayerEl.src) {
        alert('è¯·å…ˆä¸Šä¼ éŸ³é¢‘æ–‡ä»¶');
        return;
      }
      if(!headMesh || !morphTargetInfluences) {
        alert('æ¨¡å‹æœªåŠ è½½å®Œæˆï¼Œæ— æ³•é©±åŠ¨å£å‹');
        return;
      }

      // åœæ­¢å…¶å®ƒåŠ¨ç”»
      stopBuiltinAnimation();
      if(speechAnimation) speechAnimation.stopTalking();
      stopBlinking();

      // ç¡®ä¿ AudioContext
      if(!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }

      // é‡å»ºéŸ³é¢‘èŠ‚ç‚¹é“¾è·¯
      if(audioSourceNode) {
        audioSourceNode.disconnect();
      }
      audioSourceNode = audioContext.createMediaElementSource(audioPlayerEl);

      audioAnalyser = audioContext.createAnalyser();
      audioAnalyser.fftSize = 2048;
      audioTimeData = new Uint8Array(audioAnalyser.fftSize);
      audioFreqData = new Uint8Array(audioAnalyser.frequencyBinCount);

      // é“¾æ¥ï¼šsource -> analyser -> destination
      audioSourceNode.connect(audioAnalyser);
      audioAnalyser.connect(audioContext.destination);

      // æ’­æ”¾éŸ³é¢‘
      audioPlayerEl.play();
      audioDriveEnabled = true;
      autoAnimationEnabled = true;
      manualControlActive = false;
      animationMode = 'speech';

      // åŒæ­¥çœ¨çœ¼
      startBlinking();

      console.log('âœ“ å·²å¯åŠ¨éŸ³é¢‘é©±åŠ¨å£å‹');
    }

    /**
     * åœæ­¢éŸ³é¢‘é©±åŠ¨å£å‹
     */
    function stopAudioDrivenSpeech() {
      audioDriveEnabled = false;
      animationMode = 'none';
      if(audioPlayerEl) {
        audioPlayerEl.pause();
      }
      // é‡ç½®å˜´å‹
      if(speechAnimation) speechAnimation.resetMouth && speechAnimation.resetMouth();
    }

    /**
     * æ ¹æ®éŸ³é¢‘å®æ—¶é©±åŠ¨å£å‹
     */
    function driveMouthByAudio() {
      audioAnalyser.getByteTimeDomainData(audioTimeData);
      audioAnalyser.getByteFrequencyData(audioFreqData);

      // è®¡ç®—éŸ³é‡ï¼ˆRMSï¼‰
      let sum = 0;
      for(let i = 0; i < audioTimeData.length; i++) {
        const v = (audioTimeData[i] - 128) / 128; // -1~1
        sum += v * v;
      }
      const rms = Math.sqrt(sum / audioTimeData.length); // 0~1

      // è®¡ç®—é¢‘è°±é‡å¿ƒï¼ˆç®€åŒ–çš„éŸ³ç´ å€¾å‘ï¼‰
      let centroidNum = 0;
      let centroidDen = 0;
      for(let i = 0; i < audioFreqData.length; i++) {
        const mag = audioFreqData[i];
        centroidNum += mag * i;
        centroidDen += mag;
      }
      const centroid = centroidDen > 0 ? (centroidNum / centroidDen) : 0;
      const normCentroid = centroid / audioFreqData.length; // 0~1

      // å¹³æ»‘éŸ³é‡ï¼Œé¿å…å£å‹æŠ–åŠ¨
      audioSmoothLevel = audioSmoothLevel * 0.8 + rms * 0.2;

      // æ ¹æ®éŸ³é‡ç¡®å®šå¼€å£å¼ºåº¦
      const mouthOpen = THREE.MathUtils.clamp(audioSmoothLevel * 2.5, 0, 1);

      // æ ¹æ®é¢‘è°±é‡å¿ƒé€‰æ‹©æ›´åˆé€‚çš„éŸ³ç´ ï¼ˆç²—ç•¥æ˜ å°„ï¼‰
      let targetPhoneme = 'A'; // é»˜è®¤å¼€å£
      if(normCentroid > 0.6) {
        targetPhoneme = 'I'; // é«˜é¢‘å¤šï¼Œè¶‹å‘çª„å£
      } else if(normCentroid < 0.25) {
        targetPhoneme = 'U'; // ä½é¢‘å æ¯”é«˜ï¼Œè¶‹å‘åœ†å£/é—­å£
      } else if(normCentroid < 0.45) {
        targetPhoneme = 'O'; // ä¸­ä½é¢‘
      } else {
        targetPhoneme = 'E'; // ä¸­é«˜é¢‘
      }

      applyAudioPhonemePose(targetPhoneme, mouthOpen);
    }

    /**
     * å°†éŸ³é¢‘åˆ†æç»“æœæ˜ å°„åˆ°BlendShape
     */
    function applyAudioPhonemePose(phoneme, intensity) {
      if(!speechAnimation || !speechAnimation.phonemes) return;

      const indices = speechAnimation.phonemes;
      const targetIndex = indices[phoneme] !== undefined ? indices[phoneme] : indices['A'];
      const blinkIndex = expressionAnimation && expressionAnimation.expressions ? expressionAnimation.expressions.blink : undefined;

      // å…ˆæ¸…ç©ºæ‰€æœ‰éŸ³ç´ ç›¸å…³æƒé‡
      for(const idx of Object.values(indices)) {
        if(idx !== undefined) morphTargetInfluences[idx] = 0;
      }

      // åº”ç”¨ç›®æ ‡éŸ³ç´ 
      if(targetIndex !== undefined) {
        morphTargetInfluences[targetIndex] = intensity;
      }

      // è½»å¾®éšæœºåç§»æ¨¡æ‹Ÿè‡ªç„¶å£å‹å˜åŒ–
      const altPhonemes = ['A','E','I','O','U','M'].filter(p => p !== phoneme && indices[p] !== undefined);
      if(altPhonemes.length > 0 && intensity > 0.15) {
        const alt = altPhonemes[Math.floor(Math.random() * altPhonemes.length)];
        const altIdx = indices[alt];
        morphTargetInfluences[altIdx] = intensity * 0.2;
      }

      // ä¿ç•™çœ¨çœ¼çš„æƒé‡ï¼ˆå¦‚æœ‰ï¼‰
      if(blinkIndex !== undefined && morphTargetInfluences[blinkIndex] > 0.8) {
        morphTargetInfluences[blinkIndex] = 1;
      }
    }
  </script>
</body>
</html>
